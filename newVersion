import React, { useState, useCallback } from 'react';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';
import { Bar } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';

// Register Chart.js components
ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
);

// --- Helper Functions for AHP Calculations ---
const calculateWeights = (pairwiseMatrix) => {
  if (!pairwiseMatrix || pairwiseMatrix.length === 0) {
    return [];
  }
  const numCriteria = pairwiseMatrix.length;
  const columnSums = Array(numCriteria).fill(0);

  for (let j = 0; j < numCriteria; j++) {
    for (let i = 0; i < numCriteria; i++) {
      columnSums[j] += pairwiseMatrix[i][j];
    }
  }

  const normalizedMatrix = pairwiseMatrix.map(row => row.slice());
  for (let j = 0; j < numCriteria; j++) {
    for (let i = 0; i < numCriteria; i++) {
      normalizedMatrix[i][j] /= columnSums[j];
    }
  }

  const weights = Array(numCriteria).fill(0);
  for (let i = 0; i < numCriteria; i++) {
    weights[i] = normalizedMatrix[i].reduce((sum, val) => sum + val, 0) / numCriteria;
  }

  return weights;
};

const calculateConsistency = (pairwiseMatrix, weights) => {
  const numCriteria = pairwiseMatrix.length;
  if (numCriteria === 0) {
    return { cr: 0, isConsistent: true };
  }
  const weightedSumVector = Array(numCriteria).fill(0);
  for (let i = 0; i < numCriteria; i++) {
    for (let j = 0; j < numCriteria; j++) {
      weightedSumVector[i] += pairwiseMatrix[i][j] * weights[j];
    }
  }

  const consistencyVector = Array(numCriteria).fill(0);
  for (let i = 0; i < numCriteria; i++) {
    if (weights[i] !== 0) {
        consistencyVector[i] = weightedSumVector[i] / weights[i];
    }
  }

  const lambdaMax = consistencyVector.reduce((sum, val) => sum + val, 0) / numCriteria;
  const ci = (lambdaMax - numCriteria) / (numCriteria - 1);
  const ri = [0, 0, 0.58, 0.9, 1.12, 1.24, 1.32, 1.41, 1.45, 1.49][numCriteria -1] || 1.49;
  const cr = ri === 0 ? 0 : ci / ri;

  return { cr, isConsistent: cr < 0.1 };
};


// --- React Components ---

const Step1 = ({ criteria, setCriteria, options, setOptions }) => {
  const [newCriterion, setNewCriterion] = useState('');
  const [newOption, setNewOption] = useState('');

  const addCriterion = () => {
    if (newCriterion.trim() !== '' && !criteria.includes(newCriterion)) {
      setCriteria([...criteria, newCriterion]);
      setNewCriterion('');
    }
  };

  const addOption = () => {
    if (newOption.trim() !== '' && !options.includes(newOption)) {
      setOptions([...options, newOption]);
      setNewOption('');
    }
  };

  const onDragEnd = (result) => {
    if (!result.destination) return;
    const items = Array.from(criteria);
    const [reorderedItem] = items.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, reorderedItem);
    setCriteria(items);
  };

  return (
    <div>
      <h2>Step 1: Define Criteria and Options</h2>
      <div>
        <h3>Criteria</h3>
        <input
          type="text"
          value={newCriterion}
          onChange={(e) => setNewCriterion(e.target.value)}
          placeholder="Enter a new criterion"
        />
        <button onClick={addCriterion}>Add Criterion</button>
        <DragDropContext onDragEnd={onDragEnd}>
          <Droppable droppableId="criteria">
            {(provided) => (
              <ul {...provided.droppableProps} ref={provided.innerRef}>
                {criteria.map((criterion, index) => (
                  <Draggable key={criterion} draggableId={criterion} index={index}>
                    {(provided) => (
                      <li
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                      >
                        {criterion}
                      </li>
                    )}
                  </Draggable>
                ))}
                {provided.placeholder}
              </ul>
            )}
          </Droppable>
        </DragDropContext>
      </div>
      <div>
        <h3>Options</h3>
        <input
          type="text"
          value={newOption}
          onChange={(e) => setNewOption(e.target.value)}
          placeholder="Enter a new option"
        />
        <button onClick={addOption}>Add Option</button>
        <ul>
          {options.map(option => <li key={option}>{option}</li>)}
        </ul>
      </div>
    </div>
  );
};

const Step2 = ({ criteria, pairwiseMatrix, setPairwiseMatrix, weights, setWeights, consistency, setConsistency }) => {
    const handleSliderChange = (row, col, value) => {
        const newMatrix = pairwiseMatrix.map(r => r.slice());
        newMatrix[row][col] = value;
        newMatrix[col][row] = 1 / value;
        setPairwiseMatrix(newMatrix);
    };

    const calculateAndSetWeights = () => {
        const newWeights = calculateWeights(pairwiseMatrix);
        setWeights(newWeights);
        const newConsistency = calculateConsistency(pairwiseMatrix, newWeights);
        setConsistency(newConsistency);
    };

    return (
        <div>
            <h2>Step 2: Pairwise Comparison of Criteria</h2>
            {criteria.map((crit1, i) => (
                criteria.map((crit2, j) => {
                    if (i < j) {
                        return (
                            <div key={`${i}-${j}`}>
                                <span>{crit1} vs {crit2}</span>
                                <input
                                    type="range"
                                    min="1"
                                    max="9"
                                    step="1"
                                    value={pairwiseMatrix[i][j]}
                                    onChange={(e) => handleSliderChange(i, j, parseInt(e.target.value))}
                                />
                                <span>{pairwiseMatrix[i][j]}</span>
                            </div>
                        );
                    }
                    return null;
                })
            ))}
            <button onClick={calculateAndSetWeights}>Calculate Weights</button>
             {weights.length > 0 && (
                <div>
                    <h3>Relative Importance (Weights)</h3>
                    <ul>
                        {criteria.map((criterion, index) => (
                            <li key={criterion}>{criterion}: {(weights[index] * 100).toFixed(2)}%</li>
                        ))}
                    </ul>
                    <h3>Consistency</h3>
                    <p>Consistency Ratio (CR): {consistency.cr.toFixed(4)}</p>
                    <p>Is Consistent: {consistency.isConsistent ? 'Yes' : 'No (CR should be < 0.1)'}</p>
                </div>
            )}
        </div>
    );
};

const Step3 = ({ criteria, utilityFunctions, setUtilityFunctions }) => {
  const handleUtilityChange = (criterion, point, value) => {
    setUtilityFunctions(prev => ({
      ...prev,
      [criterion]: { ...prev[criterion], [point]: value }
    }));
  };

  return (
    <div>
      <h2>Step 3: Define Utility Functions</h2>
      {criteria.map(criterion => (
        <div key={criterion}>
          <h3>{criterion}</h3>
          <div>
            <label>Best Value Utility (100):</label>
            <input
              type="number"
              value={utilityFunctions[criterion]?.best || ''}
              onChange={(e) => handleUtilityChange(criterion, 'best', parseFloat(e.target.value))}
            />
          </div>
          <div>
            <label>Worst Value Utility (0):</label>
            <input
              type="number"
              value={utilityFunctions[criterion]?.worst || ''}
              onChange={(e) => handleUtilityChange(criterion, 'worst', parseFloat(e.target.value))}
            />
          </div>
        </div>
      ))}
    </div>
  );
};


const Step4 = ({ options, criteria, optionValues, setOptionValues, utilityFunctions, setUtilityScores }) => {
    const handleValueChange = (option, criterion, value) => {
        setOptionValues(prev => ({
            ...prev,
            [option]: { ...prev[option], [criterion]: value }
        }));
    };

    const calculateUtilityScores = () => {
        const newUtilityScores = {};
        options.forEach(option => {
            newUtilityScores[option] = {};
            criteria.forEach(criterion => {
                const value = parseFloat(optionValues[option]?.[criterion]);
                const best = utilityFunctions[criterion]?.best;
                const worst = utilityFunctions[criterion]?.worst;
                if (!isNaN(value) && best !== undefined && worst !== undefined) {
                    const utility = 100 * (value - worst) / (best - worst);
                     newUtilityScores[option][criterion] = Math.max(0, Math.min(100, utility));
                } else {
                    newUtilityScores[option][criterion] = 0;
                }
            });
        });
        setUtilityScores(newUtilityScores);
    };

    return (
        <div>
            <h2>Step 4: Evaluate Alternatives</h2>
            <table>
                <thead>
                    <tr>
                        <th>Option</th>
                        {criteria.map(c => <th key={c}>{c}</th>)}
                    </tr>
                </thead>
                <tbody>
                    {options.map(option => (
                        <tr key={option}>
                            <td>{option}</td>
                            {criteria.map(criterion => (
                                <td key={criterion}>
                                    <input
                                        type="number"
                                        value={optionValues[option]?.[criterion] || ''}
                                        onChange={(e) => handleValueChange(option, criterion, e.target.value)}
                                    />
                                </td>
                            ))}
                        </tr>
                    ))}
                </tbody>
            </table>
            <button onClick={calculateUtilityScores}>Calculate Utility Scores</button>
        </div>
    );
};

const Step5 = ({ options, criteria, weights, utilityScores }) => {
    const [finalScores, setFinalScores] = useState({});

    const calculateFinalScores = useCallback(() => {
        const scores = {};
        options.forEach(option => {
            let totalScore = 0;
            criteria.forEach((criterion, index) => {
                totalScore += (utilityScores[option]?.[criterion] || 0) * (weights[index] || 0);
            });
            scores[option] = totalScore;
        });
        setFinalScores(scores);
    }, [options, criteria, weights, utilityScores]);

    useState(() => {
        calculateFinalScores();
    }, [calculateFinalScores]);


    const exportToPDF = () => {
        const doc = new jsPDF();
        doc.text("AHP Analysis Report", 10, 10);

        doc.autoTable({
            head: [['Alternative', 'Final Score']],
            body: Object.entries(finalScores).map(([option, score]) => [option, score.toFixed(2)]),
        });

        doc.save('ahp-report.pdf');
    };

    const chartData = {
        labels: Object.keys(finalScores),
        datasets: [
            {
                label: 'Final Scores',
                data: Object.values(finalScores),
                backgroundColor: 'rgba(75, 192, 192, 0.6)',
            },
        ],
    };

    return (
        <div>
            <h2>Step 5: Results and Report</h2>
            <h3>Final Scores</h3>
            <ul>
                {Object.entries(finalScores)
                    .sort(([, a], [, b]) => b - a)
                    .map(([option, score]) => (
                        <li key={option}>{option}: {score.toFixed(2)}</li>
                    ))}
            </ul>
             <div style={{ height: '400px', width: '600px' }}>
              <Bar data={chartData} />
            </div>
            <button onClick={exportToPDF}>Export Report (PDF)</button>
        </div>
    );
};


function App() {
  const [criteria, setCriteria] = useState(['Risk', 'SW Effort/Schedule', 'HW Costs', 'Future Adaptability']);
  const [options, setOptions] = useState(['Dual Primary', 'Compressed Dual Primary', 'Compressed Asymmetric Primary', 'Tele-assisted Secondary']);
  const [pairwiseMatrix, setPairwiseMatrix] = useState([
    [1, 9, 7, 7],
    [1/9, 1, 3, 1/3],
    [1/7, 1/3, 1, 5],
    [1/7, 3, 1/5, 1]
  ]);
  const [weights, setWeights] = useState([]);
  const [consistency, setConsistency] = useState({ cr: 0, isConsistent: true});
  const [utilityFunctions, setUtilityFunctions] = useState({
      'Risk': { best: 100, worst: 0 },
      'SW Effort/Schedule': { best: 100, worst: 0 },
      'HW Costs': { best: 300000, worst: 400000},
      'Future Adaptability': { best: 100, worst: 0 }
  });
   const [optionValues, setOptionValues] = useState({
    'Dual Primary': { 'Risk': 100, 'SW Effort/Schedule': 60, 'HW Costs': 380000, 'Future Adaptability': 60 },
    'Compressed Dual Primary': { 'Risk': 100, 'SW Effort/Schedule': 80, 'HW Costs': 360000, 'Future Adaptability': 75 },
    'Compressed Asymmetric Primary': { 'Risk': 100, 'SW Effort/Schedule': 70, 'HW Costs': 340000, 'Future Adaptability': 80 },
    'Tele-assisted Secondary': { 'Risk': 80, 'SW Effort/Schedule': 60, 'HW Costs': 340000, 'Future Adaptability': 40 },
  });
  const [utilityScores, setUtilityScores] = useState({});


  return (
    <div className="App">
      <h1>AHP Decision-Making Tool</h1>
      <Step1 criteria={criteria} setCriteria={setCriteria} options={options} setOptions={setOptions} />
      <Step2 criteria={criteria} pairwiseMatrix={pairwiseMatrix} setPairwiseMatrix={setPairwiseMatrix} weights={weights} setWeights={setWeights} consistency={consistency} setConsistency={setConsistency} />
      <Step3 criteria={criteria} utilityFunctions={utilityFunctions} setUtilityFunctions={setUtilityFunctions} />
      <Step4 options={options} criteria={criteria} optionValues={optionValues} setOptionValues={setOptionValues} utilityFunctions={utilityFunctions} setUtilityScores={setUtilityScores} />
      {weights.length > 0 && Object.keys(utilityScores).length > 0 && (
          <Step5 options={options} criteria={criteria} weights={weights} utilityScores={utilityScores} />
      )}
    </div>
  );
}

export default App;
